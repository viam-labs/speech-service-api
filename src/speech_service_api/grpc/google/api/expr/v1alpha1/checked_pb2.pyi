"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.api.expr.v1alpha1.syntax_pb2
import google.protobuf.descriptor
import google.protobuf.empty_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class CheckedExpr(google.protobuf.message.Message):
    """Protos for representing CEL declarations and typed checked expressions.

    A CEL expression which has been successfully type checked.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ReferenceMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___Reference: ...
        def __init__(
            self,
            *,
            key: builtins.int = ...,
            value: global___Reference | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing_extensions.final
    class TypeMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___Type: ...
        def __init__(
            self,
            *,
            key: builtins.int = ...,
            value: global___Type | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    REFERENCE_MAP_FIELD_NUMBER: builtins.int
    TYPE_MAP_FIELD_NUMBER: builtins.int
    SOURCE_INFO_FIELD_NUMBER: builtins.int
    EXPR_VERSION_FIELD_NUMBER: builtins.int
    EXPR_FIELD_NUMBER: builtins.int
    @property
    def reference_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___Reference]:
        """A map from expression ids to resolved references.

        The following entries are in this table:

        - An Ident or Select expression is represented here if it resolves to a
          declaration. For instance, if `a.b.c` is represented by
          `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
          while `c` is a field selection, then the reference is attached to the
          nested select expression (but not to the id or or the outer select).
          In turn, if `a` resolves to a declaration and `b.c` are field selections,
          the reference is attached to the ident expression.
        - Every Call expression has an entry here, identifying the function being
          called.
        - Every CreateStruct expression for a message has an entry, identifying
          the message.
        """
    @property
    def type_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___Type]:
        """A map from expression ids to types.

        Every expression node which has a type different than DYN has a mapping
        here. If an expression has type DYN, it is omitted from this map to save
        space.
        """
    @property
    def source_info(self) -> google.api.expr.v1alpha1.syntax_pb2.SourceInfo:
        """The source info derived from input that generated the parsed `expr` and
        any optimizations made during the type-checking pass.
        """
    expr_version: builtins.str
    """The expr version indicates the major / minor version number of the `expr`
    representation.

    The most common reason for a version change will be to indicate to the CEL
    runtimes that transformations have been performed on the expr during static
    analysis. In some cases, this will save the runtime the work of applying
    the same or similar transformations prior to evaluation.
    """
    @property
    def expr(self) -> google.api.expr.v1alpha1.syntax_pb2.Expr:
        """The checked expression. Semantically equivalent to the parsed `expr`, but
        may have structural differences.
        """
    def __init__(
        self,
        *,
        reference_map: collections.abc.Mapping[builtins.int, global___Reference] | None = ...,
        type_map: collections.abc.Mapping[builtins.int, global___Type] | None = ...,
        source_info: google.api.expr.v1alpha1.syntax_pb2.SourceInfo | None = ...,
        expr_version: builtins.str = ...,
        expr: google.api.expr.v1alpha1.syntax_pb2.Expr | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expr", b"expr", "source_info", b"source_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expr", b"expr", "expr_version", b"expr_version", "reference_map", b"reference_map", "source_info", b"source_info", "type_map", b"type_map"]) -> None: ...

global___CheckedExpr = CheckedExpr

@typing_extensions.final
class Type(google.protobuf.message.Message):
    """Represents a CEL type."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _PrimitiveType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _PrimitiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type._PrimitiveType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        PRIMITIVE_TYPE_UNSPECIFIED: Type._PrimitiveType.ValueType  # 0
        """Unspecified type."""
        BOOL: Type._PrimitiveType.ValueType  # 1
        """Boolean type."""
        INT64: Type._PrimitiveType.ValueType  # 2
        """Int64 type.

        Proto-based integer values are widened to int64.
        """
        UINT64: Type._PrimitiveType.ValueType  # 3
        """Uint64 type.

        Proto-based unsigned integer values are widened to uint64.
        """
        DOUBLE: Type._PrimitiveType.ValueType  # 4
        """Double type.

        Proto-based float values are widened to double values.
        """
        STRING: Type._PrimitiveType.ValueType  # 5
        """String type."""
        BYTES: Type._PrimitiveType.ValueType  # 6
        """Bytes type."""

    class PrimitiveType(_PrimitiveType, metaclass=_PrimitiveTypeEnumTypeWrapper):
        """CEL primitive types."""

    PRIMITIVE_TYPE_UNSPECIFIED: Type.PrimitiveType.ValueType  # 0
    """Unspecified type."""
    BOOL: Type.PrimitiveType.ValueType  # 1
    """Boolean type."""
    INT64: Type.PrimitiveType.ValueType  # 2
    """Int64 type.

    Proto-based integer values are widened to int64.
    """
    UINT64: Type.PrimitiveType.ValueType  # 3
    """Uint64 type.

    Proto-based unsigned integer values are widened to uint64.
    """
    DOUBLE: Type.PrimitiveType.ValueType  # 4
    """Double type.

    Proto-based float values are widened to double values.
    """
    STRING: Type.PrimitiveType.ValueType  # 5
    """String type."""
    BYTES: Type.PrimitiveType.ValueType  # 6
    """Bytes type."""

    class _WellKnownType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WellKnownTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Type._WellKnownType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WELL_KNOWN_TYPE_UNSPECIFIED: Type._WellKnownType.ValueType  # 0
        """Unspecified type."""
        ANY: Type._WellKnownType.ValueType  # 1
        """Well-known protobuf.Any type.

        Any types are a polymorphic message type. During type-checking they are
        treated like `DYN` types, but at runtime they are resolved to a specific
        message type specified at evaluation time.
        """
        TIMESTAMP: Type._WellKnownType.ValueType  # 2
        """Well-known protobuf.Timestamp type, internally referenced as `timestamp`."""
        DURATION: Type._WellKnownType.ValueType  # 3
        """Well-known protobuf.Duration type, internally referenced as `duration`."""

    class WellKnownType(_WellKnownType, metaclass=_WellKnownTypeEnumTypeWrapper):
        """Well-known protobuf types treated with first-class support in CEL."""

    WELL_KNOWN_TYPE_UNSPECIFIED: Type.WellKnownType.ValueType  # 0
    """Unspecified type."""
    ANY: Type.WellKnownType.ValueType  # 1
    """Well-known protobuf.Any type.

    Any types are a polymorphic message type. During type-checking they are
    treated like `DYN` types, but at runtime they are resolved to a specific
    message type specified at evaluation time.
    """
    TIMESTAMP: Type.WellKnownType.ValueType  # 2
    """Well-known protobuf.Timestamp type, internally referenced as `timestamp`."""
    DURATION: Type.WellKnownType.ValueType  # 3
    """Well-known protobuf.Duration type, internally referenced as `duration`."""

    @typing_extensions.final
    class ListType(google.protobuf.message.Message):
        """List type with typed elements, e.g. `list<example.proto.MyMessage>`."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ELEM_TYPE_FIELD_NUMBER: builtins.int
        @property
        def elem_type(self) -> global___Type:
            """The element type."""
        def __init__(
            self,
            *,
            elem_type: global___Type | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["elem_type", b"elem_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["elem_type", b"elem_type"]) -> None: ...

    @typing_extensions.final
    class MapType(google.protobuf.message.Message):
        """Map type with parameterized key and value types, e.g. `map<string, int>`."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_TYPE_FIELD_NUMBER: builtins.int
        VALUE_TYPE_FIELD_NUMBER: builtins.int
        @property
        def key_type(self) -> global___Type:
            """The type of the key."""
        @property
        def value_type(self) -> global___Type:
            """The type of the value."""
        def __init__(
            self,
            *,
            key_type: global___Type | None = ...,
            value_type: global___Type | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["key_type", b"key_type", "value_type", b"value_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key_type", b"key_type", "value_type", b"value_type"]) -> None: ...

    @typing_extensions.final
    class FunctionType(google.protobuf.message.Message):
        """Function type with result and arg types."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESULT_TYPE_FIELD_NUMBER: builtins.int
        ARG_TYPES_FIELD_NUMBER: builtins.int
        @property
        def result_type(self) -> global___Type:
            """Result type of the function."""
        @property
        def arg_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
            """Argument types of the function."""
        def __init__(
            self,
            *,
            result_type: global___Type | None = ...,
            arg_types: collections.abc.Iterable[global___Type] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["result_type", b"result_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arg_types", b"arg_types", "result_type", b"result_type"]) -> None: ...

    @typing_extensions.final
    class AbstractType(google.protobuf.message.Message):
        """Application defined abstract type."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        PARAMETER_TYPES_FIELD_NUMBER: builtins.int
        name: builtins.str
        """The fully qualified name of this abstract type."""
        @property
        def parameter_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
            """Parameter types for this abstract type."""
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            parameter_types: collections.abc.Iterable[global___Type] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "parameter_types", b"parameter_types"]) -> None: ...

    DYN_FIELD_NUMBER: builtins.int
    NULL_FIELD_NUMBER: builtins.int
    PRIMITIVE_FIELD_NUMBER: builtins.int
    WRAPPER_FIELD_NUMBER: builtins.int
    WELL_KNOWN_FIELD_NUMBER: builtins.int
    LIST_TYPE_FIELD_NUMBER: builtins.int
    MAP_TYPE_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    MESSAGE_TYPE_FIELD_NUMBER: builtins.int
    TYPE_PARAM_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    ABSTRACT_TYPE_FIELD_NUMBER: builtins.int
    @property
    def dyn(self) -> google.protobuf.empty_pb2.Empty:
        """Dynamic type."""
    null: google.protobuf.struct_pb2.NullValue.ValueType
    """Null value."""
    primitive: global___Type.PrimitiveType.ValueType
    """Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`."""
    wrapper: global___Type.PrimitiveType.ValueType
    """Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`."""
    well_known: global___Type.WellKnownType.ValueType
    """Well-known protobuf type such as `google.protobuf.Timestamp`."""
    @property
    def list_type(self) -> global___Type.ListType:
        """Parameterized list with elements of `list_type`, e.g. `list<timestamp>`."""
    @property
    def map_type(self) -> global___Type.MapType:
        """Parameterized map with typed keys and values."""
    @property
    def function(self) -> global___Type.FunctionType:
        """Function type."""
    message_type: builtins.str
    """Protocol buffer message type.

    The `message_type` string specifies the qualified message type name. For
    example, `google.plus.Profile`.
    """
    type_param: builtins.str
    """Type param type.

    The `type_param` string specifies the type parameter name, e.g. `list<E>`
    would be a `list_type` whose element type was a `type_param` type
    named `E`.
    """
    @property
    def type(self) -> global___Type:
        """Type type.

        The `type` value specifies the target type. e.g. int is type with a
        target type of `Primitive.INT`.
        """
    @property
    def error(self) -> google.protobuf.empty_pb2.Empty:
        """Error type.

        During type-checking if an expression is an error, its type is propagated
        as the `ERROR` type. This permits the type-checker to discover other
        errors present in the expression.
        """
    @property
    def abstract_type(self) -> global___Type.AbstractType:
        """Abstract, application defined type."""
    def __init__(
        self,
        *,
        dyn: google.protobuf.empty_pb2.Empty | None = ...,
        null: google.protobuf.struct_pb2.NullValue.ValueType = ...,
        primitive: global___Type.PrimitiveType.ValueType = ...,
        wrapper: global___Type.PrimitiveType.ValueType = ...,
        well_known: global___Type.WellKnownType.ValueType = ...,
        list_type: global___Type.ListType | None = ...,
        map_type: global___Type.MapType | None = ...,
        function: global___Type.FunctionType | None = ...,
        message_type: builtins.str = ...,
        type_param: builtins.str = ...,
        type: global___Type | None = ...,
        error: google.protobuf.empty_pb2.Empty | None = ...,
        abstract_type: global___Type.AbstractType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["abstract_type", b"abstract_type", "dyn", b"dyn", "error", b"error", "function", b"function", "list_type", b"list_type", "map_type", b"map_type", "message_type", b"message_type", "null", b"null", "primitive", b"primitive", "type", b"type", "type_kind", b"type_kind", "type_param", b"type_param", "well_known", b"well_known", "wrapper", b"wrapper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["abstract_type", b"abstract_type", "dyn", b"dyn", "error", b"error", "function", b"function", "list_type", b"list_type", "map_type", b"map_type", "message_type", b"message_type", "null", b"null", "primitive", b"primitive", "type", b"type", "type_kind", b"type_kind", "type_param", b"type_param", "well_known", b"well_known", "wrapper", b"wrapper"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_kind", b"type_kind"]) -> typing_extensions.Literal["dyn", "null", "primitive", "wrapper", "well_known", "list_type", "map_type", "function", "message_type", "type_param", "type", "error", "abstract_type"] | None: ...

global___Type = Type

@typing_extensions.final
class Decl(google.protobuf.message.Message):
    """Represents a declaration of a named value or function.

    A declaration is part of the contract between the expression, the agent
    evaluating that expression, and the caller requesting evaluation.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class IdentDecl(google.protobuf.message.Message):
        """Identifier declaration which specifies its type and optional `Expr` value.

        An identifier without a value is a declaration that must be provided at
        evaluation time. An identifier with a value should resolve to a constant,
        but may be used in conjunction with other identifiers bound at evaluation
        time.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        DOC_FIELD_NUMBER: builtins.int
        @property
        def type(self) -> global___Type:
            """Required. The type of the identifier."""
        @property
        def value(self) -> google.api.expr.v1alpha1.syntax_pb2.Constant:
            """The constant value of the identifier. If not specified, the identifier
            must be supplied at evaluation time.
            """
        doc: builtins.str
        """Documentation string for the identifier."""
        def __init__(
            self,
            *,
            type: global___Type | None = ...,
            value: google.api.expr.v1alpha1.syntax_pb2.Constant | None = ...,
            doc: builtins.str = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type", b"type", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["doc", b"doc", "type", b"type", "value", b"value"]) -> None: ...

    @typing_extensions.final
    class FunctionDecl(google.protobuf.message.Message):
        """Function declaration specifies one or more overloads which indicate the
        function's parameter types and return type.

        Functions have no observable side-effects (there may be side-effects like
        logging which are not observable from CEL).
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class Overload(google.protobuf.message.Message):
            """An overload indicates a function's parameter types and return type, and
            may optionally include a function body described in terms of
            [Expr][google.api.expr.v1alpha1.Expr] values.

            Functions overloads are declared in either a function or method
            call-style. For methods, the `params[0]` is the expected type of the
            target receiver.

            Overloads must have non-overlapping argument types after erasure of all
            parameterized type variables (similar as type erasure in Java).
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            OVERLOAD_ID_FIELD_NUMBER: builtins.int
            PARAMS_FIELD_NUMBER: builtins.int
            TYPE_PARAMS_FIELD_NUMBER: builtins.int
            RESULT_TYPE_FIELD_NUMBER: builtins.int
            IS_INSTANCE_FUNCTION_FIELD_NUMBER: builtins.int
            DOC_FIELD_NUMBER: builtins.int
            overload_id: builtins.str
            """Required. Globally unique overload name of the function which reflects
            the function name and argument types.

            This will be used by a [Reference][google.api.expr.v1alpha1.Reference]
            to indicate the `overload_id` that was resolved for the function
            `name`.
            """
            @property
            def params(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
                """List of function parameter [Type][google.api.expr.v1alpha1.Type]
                values.

                Param types are disjoint after generic type parameters have been
                replaced with the type `DYN`. Since the `DYN` type is compatible with
                any other type, this means that if `A` is a type parameter, the
                function types `int<A>` and `int<int>` are not disjoint. Likewise,
                `map<string, string>` is not disjoint from `map<K, V>`.

                When the `result_type` of a function is a generic type param, the
                type param name also appears as the `type` of on at least one params.
                """
            @property
            def type_params(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
                """The type param names associated with the function declaration.

                For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
                the type params of `K, V`.
                """
            @property
            def result_type(self) -> global___Type:
                """Required. The result type of the function. For example, the operator
                `string.isEmpty()` would have `result_type` of `kind: BOOL`.
                """
            is_instance_function: builtins.bool
            """Whether the function is to be used in a method call-style `x.f(...)`
            or a function call-style `f(x, ...)`.

            For methods, the first parameter declaration, `params[0]` is the
            expected type of the target receiver.
            """
            doc: builtins.str
            """Documentation string for the overload."""
            def __init__(
                self,
                *,
                overload_id: builtins.str = ...,
                params: collections.abc.Iterable[global___Type] | None = ...,
                type_params: collections.abc.Iterable[builtins.str] | None = ...,
                result_type: global___Type | None = ...,
                is_instance_function: builtins.bool = ...,
                doc: builtins.str = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["result_type", b"result_type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["doc", b"doc", "is_instance_function", b"is_instance_function", "overload_id", b"overload_id", "params", b"params", "result_type", b"result_type", "type_params", b"type_params"]) -> None: ...

        OVERLOADS_FIELD_NUMBER: builtins.int
        @property
        def overloads(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Decl.FunctionDecl.Overload]:
            """Required. List of function overloads, must contain at least one overload."""
        def __init__(
            self,
            *,
            overloads: collections.abc.Iterable[global___Decl.FunctionDecl.Overload] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["overloads", b"overloads"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    IDENT_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The fully qualified name of the declaration.

    Declarations are organized in containers and this represents the full path
    to the declaration in its container, as in `google.api.expr.Decl`.

    Declarations used as
    [FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload]
    parameters may or may not have a name depending on whether the overload is
    function declaration or a function definition containing a result
    [Expr][google.api.expr.v1alpha1.Expr].
    """
    @property
    def ident(self) -> global___Decl.IdentDecl:
        """Identifier declaration."""
    @property
    def function(self) -> global___Decl.FunctionDecl:
        """Function declaration."""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        ident: global___Decl.IdentDecl | None = ...,
        function: global___Decl.FunctionDecl | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["decl_kind", b"decl_kind", "function", b"function", "ident", b"ident"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["decl_kind", b"decl_kind", "function", b"function", "ident", b"ident", "name", b"name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["decl_kind", b"decl_kind"]) -> typing_extensions.Literal["ident", "function"] | None: ...

global___Decl = Decl

@typing_extensions.final
class Reference(google.protobuf.message.Message):
    """Describes a resolved reference to a declaration."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    OVERLOAD_ID_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The fully qualified name of the declaration."""
    @property
    def overload_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """For references to functions, this is a list of `Overload.overload_id`
        values which match according to typing rules.

        If the list has more than one element, overload resolution among the
        presented candidates must happen at runtime because of dynamic types. The
        type checker attempts to narrow down this list as much as possible.

        Empty if this is not a reference to a
        [Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].
        """
    @property
    def value(self) -> google.api.expr.v1alpha1.syntax_pb2.Constant:
        """For references to constants, this may contain the value of the
        constant if known at compile time.
        """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        overload_id: collections.abc.Iterable[builtins.str] | None = ...,
        value: google.api.expr.v1alpha1.syntax_pb2.Constant | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "overload_id", b"overload_id", "value", b"value"]) -> None: ...

global___Reference = Reference
