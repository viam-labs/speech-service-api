/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: speech.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./google/api/annotations";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace viamlabs.service.speech.v1 {
    export class SayRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            text?: string;
            blocking?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
                if ("blocking" in data && data.blocking != undefined) {
                    this.blocking = data.blocking;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get blocking() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set blocking(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            name?: string;
            text?: string;
            blocking?: boolean;
        }): SayRequest {
            const message = new SayRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.text != null) {
                message.text = data.text;
            }
            if (data.blocking != null) {
                message.blocking = data.blocking;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                text?: string;
                blocking?: boolean;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.text != null) {
                data.text = this.text;
            }
            if (this.blocking != null) {
                data.blocking = this.blocking;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.text.length)
                writer.writeString(2, this.text);
            if (this.blocking != false)
                writer.writeBool(3, this.blocking);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SayRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SayRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.text = reader.readString();
                        break;
                    case 3:
                        message.blocking = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SayRequest {
            return SayRequest.deserialize(bytes);
        }
    }
    export class SayResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            text?: string;
        }): SayResponse {
            const message = new SayResponse({});
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                text?: string;
            } = {};
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.text.length)
                writer.writeString(1, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SayResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SayResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SayResponse {
            return SayResponse.deserialize(bytes);
        }
    }
    export class ToTextRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            speech?: Uint8Array;
            format?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("speech" in data && data.speech != undefined) {
                    this.speech = data.speech;
                }
                if ("format" in data && data.format != undefined) {
                    this.format = data.format;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get speech() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set speech(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get format() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set format(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            name?: string;
            speech?: Uint8Array;
            format?: string;
        }): ToTextRequest {
            const message = new ToTextRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.speech != null) {
                message.speech = data.speech;
            }
            if (data.format != null) {
                message.format = data.format;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                speech?: Uint8Array;
                format?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.speech != null) {
                data.speech = this.speech;
            }
            if (this.format != null) {
                data.format = this.format;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.speech.length)
                writer.writeBytes(2, this.speech);
            if (this.format.length)
                writer.writeString(3, this.format);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToTextRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToTextRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.speech = reader.readBytes();
                        break;
                    case 3:
                        message.format = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToTextRequest {
            return ToTextRequest.deserialize(bytes);
        }
    }
    export class ToTextResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            text?: string;
        }): ToTextResponse {
            const message = new ToTextResponse({});
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                text?: string;
            } = {};
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.text.length)
                writer.writeString(1, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToTextResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToTextResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToTextResponse {
            return ToTextResponse.deserialize(bytes);
        }
    }
    export class ToSpeechRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            text?: string;
        }): ToSpeechRequest {
            const message = new ToSpeechRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                text?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.text.length)
                writer.writeString(2, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToSpeechRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToSpeechRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToSpeechRequest {
            return ToSpeechRequest.deserialize(bytes);
        }
    }
    export class ToSpeechResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            speech?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("speech" in data && data.speech != undefined) {
                    this.speech = data.speech;
                }
            }
        }
        get speech() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set speech(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            speech?: Uint8Array;
        }): ToSpeechResponse {
            const message = new ToSpeechResponse({});
            if (data.speech != null) {
                message.speech = data.speech;
            }
            return message;
        }
        toObject() {
            const data: {
                speech?: Uint8Array;
            } = {};
            if (this.speech != null) {
                data.speech = this.speech;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.speech.length)
                writer.writeBytes(1, this.speech);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ToSpeechResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ToSpeechResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.speech = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ToSpeechResponse {
            return ToSpeechResponse.deserialize(bytes);
        }
    }
    export class CompletionRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            text?: string;
            blocking?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
                if ("blocking" in data && data.blocking != undefined) {
                    this.blocking = data.blocking;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get blocking() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set blocking(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            name?: string;
            text?: string;
            blocking?: boolean;
        }): CompletionRequest {
            const message = new CompletionRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.text != null) {
                message.text = data.text;
            }
            if (data.blocking != null) {
                message.blocking = data.blocking;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                text?: string;
                blocking?: boolean;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.text != null) {
                data.text = this.text;
            }
            if (this.blocking != null) {
                data.blocking = this.blocking;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.text.length)
                writer.writeString(2, this.text);
            if (this.blocking != false)
                writer.writeBool(3, this.blocking);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompletionRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompletionRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.text = reader.readString();
                        break;
                    case 3:
                        message.blocking = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompletionRequest {
            return CompletionRequest.deserialize(bytes);
        }
    }
    export class CompletionResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            text?: string;
        }): CompletionResponse {
            const message = new CompletionResponse({});
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                text?: string;
            } = {};
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.text.length)
                writer.writeString(1, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompletionResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompletionResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompletionResponse {
            return CompletionResponse.deserialize(bytes);
        }
    }
    export class GetCommandsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            number?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("number" in data && data.number != undefined) {
                    this.number = data.number;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get number() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set number(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            number?: number;
        }): GetCommandsRequest {
            const message = new GetCommandsRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.number != null) {
                message.number = data.number;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                number?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.number != null) {
                data.number = this.number;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.number != 0)
                writer.writeInt32(2, this.number);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetCommandsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetCommandsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.number = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetCommandsRequest {
            return GetCommandsRequest.deserialize(bytes);
        }
    }
    export class GetCommandsResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            commands?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("commands" in data && data.commands != undefined) {
                    this.commands = data.commands;
                }
            }
        }
        get commands() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set commands(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            commands?: string[];
        }): GetCommandsResponse {
            const message = new GetCommandsResponse({});
            if (data.commands != null) {
                message.commands = data.commands;
            }
            return message;
        }
        toObject() {
            const data: {
                commands?: string[];
            } = {};
            if (this.commands != null) {
                data.commands = this.commands;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.commands.length)
                writer.writeRepeatedString(1, this.commands);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetCommandsResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetCommandsResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetCommandsResponse {
            return GetCommandsResponse.deserialize(bytes);
        }
    }
    export class ListenTriggerRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            type?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            type?: string;
        }): ListenTriggerRequest {
            const message = new ListenTriggerRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                type?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.type.length)
                writer.writeString(2, this.type);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListenTriggerRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListenTriggerRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.type = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListenTriggerRequest {
            return ListenTriggerRequest.deserialize(bytes);
        }
    }
    export class ListenTriggerResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            text?: string;
        }): ListenTriggerResponse {
            const message = new ListenTriggerResponse({});
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                text?: string;
            } = {};
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.text.length)
                writer.writeString(1, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListenTriggerResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListenTriggerResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListenTriggerResponse {
            return ListenTriggerResponse.deserialize(bytes);
        }
    }
    export class IsSpeakingRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            name?: string;
        }): IsSpeakingRequest {
            const message = new IsSpeakingRequest({});
            if (data.name != null) {
                message.name = data.name;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsSpeakingRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsSpeakingRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IsSpeakingRequest {
            return IsSpeakingRequest.deserialize(bytes);
        }
    }
    export class IsSpeakingResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set status(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            status?: boolean;
        }): IsSpeakingResponse {
            const message = new IsSpeakingResponse({});
            if (data.status != null) {
                message.status = data.status;
            }
            return message;
        }
        toObject() {
            const data: {
                status?: boolean;
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status != false)
                writer.writeBool(1, this.status);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IsSpeakingResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IsSpeakingResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IsSpeakingResponse {
            return IsSpeakingResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedSpeechServiceService {
        static definition = {
            Say: {
                path: "/viamlabs.service.speech.v1.SpeechService/Say",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: SayRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => SayRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SayResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SayResponse.deserialize(new Uint8Array(bytes))
            },
            ToText: {
                path: "/viamlabs.service.speech.v1.SpeechService/ToText",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ToTextRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ToTextRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ToTextResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ToTextResponse.deserialize(new Uint8Array(bytes))
            },
            ToSpeech: {
                path: "/viamlabs.service.speech.v1.SpeechService/ToSpeech",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ToSpeechRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ToSpeechRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ToSpeechResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ToSpeechResponse.deserialize(new Uint8Array(bytes))
            },
            Completion: {
                path: "/viamlabs.service.speech.v1.SpeechService/Completion",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: CompletionRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => CompletionRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: CompletionResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => CompletionResponse.deserialize(new Uint8Array(bytes))
            },
            GetCommands: {
                path: "/viamlabs.service.speech.v1.SpeechService/GetCommands",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetCommandsRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetCommandsRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetCommandsResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetCommandsResponse.deserialize(new Uint8Array(bytes))
            },
            ListenTrigger: {
                path: "/viamlabs.service.speech.v1.SpeechService/ListenTrigger",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ListenTriggerRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ListenTriggerRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ListenTriggerResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ListenTriggerResponse.deserialize(new Uint8Array(bytes))
            },
            IsSpeaking: {
                path: "/viamlabs.service.speech.v1.SpeechService/IsSpeaking",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: IsSpeakingRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => IsSpeakingRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: IsSpeakingResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => IsSpeakingResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Say(call: grpc_1.ServerUnaryCall<SayRequest, SayResponse>, callback: grpc_1.sendUnaryData<SayResponse>): void;
        abstract ToText(call: grpc_1.ServerUnaryCall<ToTextRequest, ToTextResponse>, callback: grpc_1.sendUnaryData<ToTextResponse>): void;
        abstract ToSpeech(call: grpc_1.ServerUnaryCall<ToSpeechRequest, ToSpeechResponse>, callback: grpc_1.sendUnaryData<ToSpeechResponse>): void;
        abstract Completion(call: grpc_1.ServerUnaryCall<CompletionRequest, CompletionResponse>, callback: grpc_1.sendUnaryData<CompletionResponse>): void;
        abstract GetCommands(call: grpc_1.ServerUnaryCall<GetCommandsRequest, GetCommandsResponse>, callback: grpc_1.sendUnaryData<GetCommandsResponse>): void;
        abstract ListenTrigger(call: grpc_1.ServerUnaryCall<ListenTriggerRequest, ListenTriggerResponse>, callback: grpc_1.sendUnaryData<ListenTriggerResponse>): void;
        abstract IsSpeaking(call: grpc_1.ServerUnaryCall<IsSpeakingRequest, IsSpeakingResponse>, callback: grpc_1.sendUnaryData<IsSpeakingResponse>): void;
    }
    export class SpeechServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedSpeechServiceService.definition, "SpeechService", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        Say: GrpcUnaryServiceInterface<SayRequest, SayResponse> = (message: SayRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SayResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SayResponse>, callback?: grpc_1.requestCallback<SayResponse>): grpc_1.ClientUnaryCall => {
            return super.Say(message, metadata, options, callback);
        };
        ToText: GrpcUnaryServiceInterface<ToTextRequest, ToTextResponse> = (message: ToTextRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ToTextResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ToTextResponse>, callback?: grpc_1.requestCallback<ToTextResponse>): grpc_1.ClientUnaryCall => {
            return super.ToText(message, metadata, options, callback);
        };
        ToSpeech: GrpcUnaryServiceInterface<ToSpeechRequest, ToSpeechResponse> = (message: ToSpeechRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ToSpeechResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ToSpeechResponse>, callback?: grpc_1.requestCallback<ToSpeechResponse>): grpc_1.ClientUnaryCall => {
            return super.ToSpeech(message, metadata, options, callback);
        };
        Completion: GrpcUnaryServiceInterface<CompletionRequest, CompletionResponse> = (message: CompletionRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<CompletionResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<CompletionResponse>, callback?: grpc_1.requestCallback<CompletionResponse>): grpc_1.ClientUnaryCall => {
            return super.Completion(message, metadata, options, callback);
        };
        GetCommands: GrpcUnaryServiceInterface<GetCommandsRequest, GetCommandsResponse> = (message: GetCommandsRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetCommandsResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetCommandsResponse>, callback?: grpc_1.requestCallback<GetCommandsResponse>): grpc_1.ClientUnaryCall => {
            return super.GetCommands(message, metadata, options, callback);
        };
        ListenTrigger: GrpcUnaryServiceInterface<ListenTriggerRequest, ListenTriggerResponse> = (message: ListenTriggerRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ListenTriggerResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ListenTriggerResponse>, callback?: grpc_1.requestCallback<ListenTriggerResponse>): grpc_1.ClientUnaryCall => {
            return super.ListenTrigger(message, metadata, options, callback);
        };
        IsSpeaking: GrpcUnaryServiceInterface<IsSpeakingRequest, IsSpeakingResponse> = (message: IsSpeakingRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<IsSpeakingResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<IsSpeakingResponse>, callback?: grpc_1.requestCallback<IsSpeakingResponse>): grpc_1.ClientUnaryCall => {
            return super.IsSpeaking(message, metadata, options, callback);
        };
    }
}
